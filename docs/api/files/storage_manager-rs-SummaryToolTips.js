NDSummary.OnToolTipsLoaded("File:storage_manager.rs",{2:"<div class=\"NDToolTip TType LRust\"><div class=\"TTSummary\">Type alias for Keys, it\'s just a String</div></div>",3:"<div class=\"NDToolTip TType LRust\"><div class=\"TTSummary\">Type alias for Values, it\'s just a String</div></div>",4:"<div class=\"NDToolTip TClass LRust\"><div class=\"NDClassPrototype\" id=\"NDClassPrototype4\"><div class=\"CPEntry TClass Current\"><div class=\"CPModifiers\">pub <span class=\"SHKeyword\">struct</span></div><div class=\"CPName\">StorageManager</div></div></div><div class=\"TTSummary\">This is the Rust side of the storage manager.&nbsp; The real work is performed in the kotlin and swift functions, but this exposes that in a platform neutral way to our rust code.</div></div>",6:"<div class=\"NDToolTip TVariable LRust\"><div class=\"TTSummary\">Callback function pointer to native (kotlin/swift) code for adding a key.</div></div>",7:"<div class=\"NDToolTip TVariable LRust\"><div class=\"TTSummary\">Callback function pointer to native (kotlin/swift) code for getting a key.</div></div>",8:"<div class=\"NDToolTip TVariable LRust\"><div class=\"TTSummary\">Callback function pointer to native (kotlin/swift) code for removing a key.&nbsp; This referenced function MUST be idempotent.&nbsp; In particular, it must treat removing a non-existent key as a normal and expected circumstance, simply returning Unit and not an error.</div></div>",10:"<div class=\"NDToolTip TFunction LRust\"><div class=\"TTSummary\">Adds Value for Key.&nbsp; Should the key already exist, it is replaced</div></div>",11:"<div class=\"NDToolTip TFunction LRust\"><div class=\"TTSummary\">Attempts to fetch a value stored under Key from SecureStorage, Should the value not exist, None is returned</div></div>"});